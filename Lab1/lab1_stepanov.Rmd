---
title: "Лабораторная работа"
author: "Степанов Г.А."
date: "16 11 2020"
output: word_document
---
```{r setup, include = FALSE}

# Загрузка библиотек
library('knitr')
library('Hmisc')          # для расчёта корреляционной матрицы
library('corrplot')       # визуализация корреляционных матриц: corrplot()
library('nortest')        # для теста Андерсона-Дарлинга ad.test()
knitr::opts_chunk$set(echo = FALSE)
```

# Раздел I.
В этом разделе необходимо собрать данные по социально-экономическим показателям в регионах РФ и изучить их взаимосвязи.

**Необходимо построить:**

* Фактические плотности распределения переменных с наложенными теоретическими плотностями нормального закона (разместить графики на одном полотне).

* Тест  Андерсона-Дарлинга на нормальность: таблица со статистикой теста, P-значением и выводом по каждой переменной.

* Точечные графики взаимного разброса, только над главной диагональю, сделать маркеры полупрозрачными.

* Взаимосвязь показателей: графическое представление корреляционной матрицы. Незначимые коэффициенты корреляции скрыть, остальные показать квадратами.

### Обозначения количественных показателей:

* `SREDDENDOXOD2012` – Среднедушевые денежные доходы населения.   

* `VRP2012` – ВРП на душу населения.   

* `Y.ORTorg.2012` –Оборот розничной торговли на душу населения.   

* `RKBS.2011` – Расходы консолидированных бюджетов субъектов Российской Федерации: на социальную политику.   

* `KMPred.2012` – Число малых предприятий на 10000 человек населения.

## Импорт данных:

```{r import}
# импорт данных из .csv
file.path <- 'Dannye_stepanov.csv'
DF <- read.csv2(file.path, stringsAsFactors = F)

```

Файл с данными содержит `r nrow(DF)` строк и `r ncol(DF)` столбцов.   

```{r}
# делаем из столбца "FO" фактор
DF$FO <- factor(DF$FO)
    
# оставляем только регионы и выбрасываем столбец меток, 
#  чтобы удобнее было считать
reg.df <- DF[DF$Reg.code < 1000, c(-1, -2)]
# выбрасываем пропущенные
reg.df <- na.omit(reg.df)

```

## Описательная статистика  


```{r}
# ручной расчёт
#  средние арифметические
mns <- round(apply(reg.df[, -1], 2, mean), 1)

#  стандартные отклонения
sds <- round(apply(reg.df[, -1], 2, sd), 1)

#  коэффициенты вариации
coef.vars <- round(sds / mns * 100, 1)

# делаем свою таблицу только с нужными статистиками 
#  по количественным показателям: среднее, СКО, коэффициент вариации
smm <- rbind(mns, sds, coef.vars)
# названия статистик -- заголовки строк
row.names(smm) <- c('Среднее', 'Стандартное отклонение',
                    'Коэффициент вариации, %')

kable(smm)

```

**Вывод:** показатели неоднородны.   

## Анализ распределения данных

Построим гистограммы с их фактическими плотностями распределений и наложим сверху теоретическую нормальную плотность распределения.


```{r}
# строим гистограммы на одном полотне по изначальным данным
par(mfrow = c(2, 3))           # разбить полотно на 6 частей, 2x3
par(oma = c(0, 0, 1.5, 0))     # внешние поля общего полотна
par(mar = c(4, 4, 0.5, 0.5))   # внутренние поля каждого графика

# цикл по номерам столбцов с количественными переменными
for (i in 2:6) {
  # данные -- i-ый столбец фрейма
  x <- reg.df[, i]
  
  # гистограмма
  hist(x,
       freq = F,            # по вертикали – плотность (доля)
       col = 'wheat',       # цвет заливки
       xlab = colnames(reg.df)[i],     # название оси X – название столбца 
       ylab = 'Плотность',             # название оси Y
       main = '')                      # без заголовка
  
  #фактическая плотность
  lines(density(x),col = "red", lwd = 2)
  
  # теоретическая плотность
  curve(dnorm(x, mean = mean(x), sd = sd(x)), col = 'darkblue', 
        lwd = 2, add = TRUE)

}

# общий заголовок для всех графиков
title(main = 'Гистограммы распределения показателей', 
      outer = TRUE, cex = 1.5)

# вернуть настройки обратно, 1x1
par(mfrow = c(1, 1))

```

**Вывод:** Судя по гистограммам, распределения всех показателей ассиметричны по сравнению с нормальным законом.(Особенно это заметно у *"SREDDENDOXOD2012"*, *"VRP2012"* и *"RKBS.2011"*) Кроме того, показатели имеют более островершинные распределения по сравнению с нормальным законом.

## Тест Андерсона-Дарлинга на нормальность распределения

```{r}
# применяем ко всем столбцам и вытаскиваем только тестовую статистику
# для изначальных значений
W <- sapply(reg.df[, 2:6], function(x) {
  round(ad.test(x)$statistic, 4)
})
p <- sapply(reg.df[, 2:6], function(x) {
  round(ad.test(x)$p.value, 4)
})

table <- data.frame(p, W)
kable(table)

```

**Вывод:**: По итогам теста Андерсона-Дарлинга на нормальность распредления переменных (при уровне значимости 0,05) отвергается нулевая гипотеза о нормальности распределения для всех пяти показателей *"SREDDENDOXOD2012"*, *"VRP2012"*, *"RKBS.2011"*, *"KMPred.2012 "*, *"Y.ORTorg.2012 "*, т.к. P-значения < 0.05. Следовательно, данные не имеют нормального распределения.

## Графики разброса

```{r}
# графики взаимного разброса по изначальным данным
pairs(reg.df[, -1],     # фрейм без первого столбца-фактора
      pch = 2,         # тип символов для точек
      col = rgb(1, 0, 0, alpha = 0.4),   # цвет заливки точек
      bg = rgb(0, 0, 1, alpha = 0.4),    # цвет границы точек
      cex = 1.1)                 # масштаб символов для точек

```

**Вывод:** по первой строке графиков попытаемся определить наличие связи между *"SREDDENDOXOD2012"* и остальными показателями. Вероятно, что связь сильная есть со следующими показателями: *"Y.ORTorg.2012"*. С *"KMPred.2012"*, *"VRP2012"*, *"RKBS.2011"*  возможны средние положительные линейные связи. Чтобы проверить эти предположения, рассчитаем корреляционную матрицу и проверим коэффициенты на значимость.

## Корреляционная матрица

```{r}

# коэффициенты Пирсона с P-значениями
r.corr <- rcorr(as.matrix(reg.df[, -1]))

# Визуализация корреляционной матрицы  =========================================

# сохраняем корреляционную матрицу
matrix.cor <- r.corr$r

# сохраняем p-значения
matrix.p <- r.corr$P

# изображаем матрицу графически
corrplot(matrix.cor, method = "square",         # сама корреляционная матрица
         order = 'original',  # порядок отображения показателей 
         # в матрице
         diag = F,            # не отображать значения на главной 
         # диагонали
         p.mat = matrix.p,    # p-значения
        insig = 'blank',     # метод отображения незначимых
         sig.level = 0.05)    # уровень значимости
title(ylab = 'Корреляция показателей')

```

**Вывод:** На основании корредяционной матрицы мы можем сделать вывод, что между показателями *"SREDDENDOXOD2012"* и *"Y.ORTorg.2012"* наблюдается сильная прямая корредяционная зависимость, также как между *"Y.ORTorg.2012"* и *"RKBS.2011"*. Между показателями *"SREDDENDOXOD2012"* и *"VRP2012"*  наблюдается заметная прямая корреляционная зависимость, также как между *"Y.ORTorg.2012"* и *"KMPred.2012"*. Между показателями  *"SREDDENDOXOD2012"* и *"RKBS.2011";* *"SREDDENDOXOD2012"* и *"KMPred.2012";* *"VRP2012"* и *"Y.ORTorg.2012"* прямая умеренная связь.


***

# Раздел II.

В этом разделе необходимо прологарифмировать данные из первого раздела и провести с новыми данными те же махинации.

## Описательная статистика логарифмированных данных:

```{r}
#фрейм с логарифмированными данными
DF1 <- reg.df
DF1$SREDDENDOXOD2012 <- log(reg.df$SREDDENDOXOD2012)
DF1$VRP2012 <- log(reg.df$VRP2012)
DF1$Y.ORTorg.2012 <- log(reg.df$Y.ORTorg.2012)
DF1$RKBS.2011 <- log(reg.df$RKBS.2011)
DF1$KMPred.2012 <- log(reg.df$KMPred.2012)

# ручной расчёт
#  средние арифметические
mns1 <- round(apply(DF1[, -1], 2, mean), 3)

#  стандартные отклонения
sds1 <- round(apply(DF1[, -1], 2, sd), 3)

#  коэффициенты вариации
coef.vars1 <- round(sds1 / mns1 * 100, 3)

# делаем свою таблицу только с нужными статистиками 
#  по количественным показателям: среднее, СКО, коэффициент вариации
smm1 <- rbind(mns1, sds1, coef.vars1)
# названия статистик -- заголовки строк
row.names(smm1) <- c('Среднее', 'Стандартное отклонение',
                    'Коэффициент вариации, %')
kable(smm1)
```

**Вывод:** показатели считаются однородными, т.к. коэффициенты вариации не превышают 10%.

## Анализ распределения данных

Построим гистограммы с их фактическими плотностями распределений и наложим сверху теоретическую нормальную плотность распределения.

```{r}

# строим гистограммы на одном полотне по логарифмированным данным
par(mfrow = c(2, 3))           # разбить полотно на 6 частей, 2x3
par(oma = c(0, 0, 1.5, 0))     # внешние поля общего полотна
par(mar = c(4, 4, 0.5, 0.5))   # внутренние поля каждого графика

# цикл по номерам столбцов с количественными переменными
for (i in 2:6) {
  # данные -- i-ый столбец фрейма
  x <- DF1[, i]
  
  # гистограмма
  hist(x,
       freq = F,            # по вертикали – плотность (доля)
       col = 'wheat',       # цвет заливки
       xlab = colnames(reg.df)[i],     # название оси X – название столбца 
       ylab = 'Плотность',             # название оси Y
       main = '')                      # без заголовка
  
  #фактическая плотность
  lines(density(x),col = "blue", lwd = 2)
  
  # теоретическая плотность
  curve(dnorm(x, mean = mean(x), sd = sd(x)), col = 'black', 
        lwd = 2, add = TRUE)
  
}

# общий заголовок для всех графиков
title(main = 'Гистограммы распределения логарифмированных показателей', 
      outer = TRUE, cex = 1.5)

# вернуть настройки обратно, 1x1
par(mfrow = c(1, 1))

```

**Вывод:** Судя по гистограммам, распределения всех показателей ассиметричны по сравнению с нормальным законом.(Особенно это заметно у *"KMPred.2012"* и *"Y.ORTorg.2012"*) Кроме того, показатели имеют более островершинные распределения по сравнению с нормальным законом.

## Тест Андерсона-Дарлинга на нормальность распределения

```{r}
# применяем ко всем столбцам и вытаскиваем только тестовую статистику
# для изначальных значений
W <- sapply(DF1[, 2:6], function(x) {
  round(ad.test(x)$statistic, 4)
})
p <- sapply(DF1[, 2:6], function(x) {
  round(ad.test(x)$p.value, 4)
})

table1 <- data.frame(p, W)
kable(table1)

```

**Вывод:** Проверяя гипотезу нормального распределения для переменных на уровне значимости 0.05, мы отвергаем все, кроме *"RKBS.2011"*, так как остальные p-значения < 0.05 .

## Графики разброса

```{r}
# графики взаимного разброса по логарифмированным данным
pairs(DF1[, -1],     # фрейм без первого столбца-фактора
      pch = 5,         # тип символов для точек
      col = rgb(0, 0, 1, alpha = 0.4),   # цвет заливки точек
      bg = rgb(0, 0, 1, alpha = 0.4),    # цвет границы точек
      cex = 1.1)                 # масштаб символов для точек

```

**Вывод:** по первой строке графиков попытаемся определить наличие связи между *"SREDDENDOXOD2012"* и остальными показателями. Можно предположить, что со всеми показателями существует прямая положительная связь,чтобы проверить эти предположения, рассчитаем корреляционную матрицу и проверим коэффициенты на значимость.

## Корреляционная матрица

```{r}
# коэффициенты Пирсона с P-значениями
r.corr <- rcorr(as.matrix(DF1[, -1]))

# Визуализация корреляционной матрицы  =========================================

# сохраняем корреляционную матрицу
matrix.cor <- r.corr$r

# сохраняем p-значения
matrix.p <- r.corr$P

# изображаем матрицу графически
corrplot(matrix.cor, method = "square",         # сама корреляционная матрица
         order = 'original',  # порядок отображения показателей 
         # в матрице
         diag = F,            # не отображать значения на главной 
         # диагонали
         p.mat = matrix.p,    # p-значения
         insig = 'blank',     # метод отображения незначимых
         sig.level = 0.05)    # уровень значимости
title(ylab = 'Корреляция логарифмированных показателей')

```

**Вывод:** Сильная взаимосвязь  *"SREDDENDOXOD2012"* значима с показателями *"VRP2012"* и *"Y.ORTorg.2012"*.Между другими показателями заметно увеличилась связь.

```{r}
 #5. Сохранение рабочего пространства  ------------------------------------------


# сохраняем нужные объекты в файл
save(list = c('DF', 'reg.df', 'DF1'), file = 'test_lab1_Степанов.RData')
save.image('test_lab1_Степанов.RData')
rm()

```